unit BaseClass;

interface

uses
  Base.Collections,
  StrUtils,
  System.SysUtils;

type
  TBuilderSQL = class
  strict protected
    Table: string;
    Fields: TCollectionsSQL;
    Wheres: TCollectionsSQL;
  public
    function AddTable( const ATable: string ): TBuilderSQL;

    function AddField( const AField: string; const AValue: Variant ): TBuilderSQL; overload;

    function AddWhere( const AField: string; const AValue: Variant ): TBuilderSQL; overload;
    function AddWhere( const ATable: string; const AField: string; const AValue: Variant ): TBuilderSQL; overload;

    function GetSQL(): string; virtual;
  end;

  TInsertSQL = class( TBuilderSQL )
    function GetSQL(): string; override;
    class function Builder(): TBuilderSQL;
  end;


  {$IFDEF INTERFACE}
  ICommandSQL = interface ['{9FA3224F-ED1B-48FE-8BF7-EB11084E51EE}']
    function SQL(): string;
  end;
  {$ENDIF}
  TCommandSQL = class {$IFDEF INTERFACE}( TInterfacedObject, ICommandSQL ) {$ENDIF}
  strict private
    BuilderSQL: TBuilderSQL;
  public
    destructor Destroy(); override;
    constructor Create( const ABuilderSQL: TBuilderSQL );
    function SQL(): string;
    class function Builder( const ABuilderSQL: TBuilderSQL ): {$IFDEF INTERFACE} ICommandSQL {$ELSE} TCommandSQL {$ENDIF};
  end;


implementation

uses
  Vcl.Dialogs;

{ TBuilder }

class function TCommandSQL.Builder( const ABuilderSQL: TBuilderSQL ): {$IFDEF INTERFACE} ICommandSQL {$ELSE} TCommandSQL {$ENDIF};
begin
  Result:= TCommandSQL.Create( ABuilderSQL );
end;



constructor TCommandSQL.Create(const ABuilderSQL: TBuilderSQL);
begin
  BuilderSQL:= ABuilderSQL;
end;

destructor TCommandSQL.Destroy;
begin

  if ( Assigned( BuilderSQL ) ) then
    FreeAndNil( BuilderSQL );

  inherited;
end;



function TCommandSQL.SQL: string;
begin
  Result:= BuilderSQL.GetSQL();
end;



{ TCommandSQL }

function TBuilderSQL.AddTable(const ATable: string): TBuilderSQL;
begin
  Table:= ATable;

  Result:= Self;
end;



function TBuilderSQL.AddField(const AField: string;
  const AValue: Variant): TBuilderSQL;
begin
 Fields.Add( EmptyStr, AField, AValue );

 Result:= Self;
end;



function TBuilderSQL.AddWhere(const AField: string;
  const AValue: Variant): TBuilderSQL;
begin
  AddWhere( EmptyStr, AField, AValue );

  Result:= Self;
end;



function TBuilderSQL.AddWhere(const ATable, AField: string;
  const AValue: Variant): TBuilderSQL;
begin
  Wheres.Add( ATable, AField, AValue );

  Result:= Self;
end;


function TBuilderSQL.GetSQL: string;
begin
  raise Exception.Create('Função não implementada');
end;

{ TInsertSQL }

class function TInsertSQL.Builder: TBuilderSQL;
begin
  Result:= TInsertSQL.Create();
end;



function TInsertSQL.GetSQL: string;

  function VariantToString( const AValue: Variant ): string;
  begin
    case ( TVarData( AValue ).VType ) of
      varSmallint, varInteger, varByte,
      varWord, varLongWord, varInt64:
        Result:= IntToStr ( Integer( AValue ) );

      varString, varUString:
        Result:= QuotedStr( String( AValue ) );

      varDate:
        //Result:= QuotedStr( FormatDateTime( 'yyyy-mm-dd hh:nn:ss', AValue ) )
        Result:= QuotedStr( FormatDateTime( 'yyyy-mm-dd', AValue ) )


      else
        raise Exception.Create('Tipo da variável não definida');
    end;

  end;

  function GetFields(): string;
  var
    Indice: Integer;
  begin
    Result:= EmptyStr;
    for Indice := Low( Fields.Collection ) to High(  Fields.Collection ) do
      Result:= Result + IfThen( Indice > 0, ', ' ) + Fields.Collection[Indice].Field  ;
  end;


  function GetFieldsValues(): string;
  var
    Indice: Integer;
  begin
    Result:= EmptyStr;
    for Indice := Low( Fields.Collection ) to High(  Fields.Collection ) do
      Result:= Result + IfThen( Indice > 0, ', ' ) + VariantToString ( Fields.Collection[Indice].Value );
  end;


begin
  Result:=
    'insert into ' + Table + ' ( ' +

     GetFields() +

    ' ) values ( ' +

    GetFieldsValues() +

    ' )';
end;





end.
